#include "read_sensors.h"

int reflectionRate = REFLECTION_RATE_;
const float LOW_BAT_TH = LOW_BAT_TH_;

int32_t volMeter=0;
float voltage = 0;
int32_t LFSensor = 0;
int32_t RFSensor = 0;
int32_t DLSensor = 0;
int32_t DRSensor = 0;
int32_t LLSensor = 0;
int32_t RRSensor = 0;

int32_t LFSensor_ = 0;

int32_t LFSensor_bg = 0;
int32_t RFSensor_bg = 0;
int32_t DLSensor_bg = 0;
int32_t DRSensor_bg = 0;
int32_t LLSensor_bg = 0;
int32_t RRSensor_bg = 0;
int32_t MTRSensor_bg = 0;

// DC offset due to the reflections from robot itself
int32_t LFSensor_DC = 0; //1100;
int32_t RFSensor_DC = 0; //1330;
int32_t DLSensor_DC = 0; //530;
int32_t DRSensor_DC = 0; //500;
int32_t LLSensor_DC = 0;
int32_t RRSensor_DC = 0;

int32_t count=0;
float l_offset;
float r_offset;

static int32_t LBuff[15] = {0};
static int32_t RBuff[15] = {0};
static int32_t FLBuff[15] = {0};
static int32_t FRBuff[15] = {0};
static int32_t LLBuff[15] = {0};
static int32_t RRBuff[15] = {0};

float averageL = 0;
float averageR = 0;
float averageFL = 0;
float averageFR = 0;
float averageLL = 0;
float averageRR = 0;

bool L = false;
bool R = false;
bool F = false;

int start_count = 0;
int elapse_count = 60;

static int point = 0;

/*read IR sensors*/
void readSensor(void)
{
//	LED7_ON;

	//read ambient values
	LFSensor_bg = read_LF_Sensor;
	RFSensor_bg = read_RF_Sensor;
	DLSensor_bg = read_DL_Sensor;
	DRSensor_bg = read_DR_Sensor;
	LLSensor_bg = read_LL_Sensor;
	RRSensor_bg = read_RR_Sensor;
	
	__HAL_TIM_SET_COUNTER(&htim5,0);

    //left front sensor
	LF_EM_ON;
//	start_count = __HAL_TIM_GET_COUNTER(&htim5);
	while(__HAL_TIM_GET_COUNTER(&htim5)< 50); //start_count + elapse_count);  //60
	LFSensor = read_LF_Sensor - LFSensor_bg - LFSensor_DC;
//	LFSensor = (int32_t)1.142*LFSensor - 539.4;
	LF_EM_OFF;
//	start_count = __HAL_TIM_GET_COUNTER(&htim5);
	if(LFSensor < 0)//error check
		LFSensor = 0;
	while(__HAL_TIM_GET_COUNTER(&htim5)<100); //start_count + elapse_count);  //140

//    right side sensor
//	R_EM_ON;
//	start_count = __HAL_TIM_GET_COUNTER(&htim5);
//	while(__HAL_TIM_GET_COUNTER(&htim5)<start_count + elapse_count);
//	RRSensor = read_RR_Sensor - RRSensor_bg - RRSensor_DC;
//	R_EM_OFF;
//	start_count = __HAL_TIM_GET_COUNTER(&htim5);
//	if(RRSensor < 0)//error check
//		RRSensor = 0;
//	while(__HAL_TIM_GET_COUNTER(&htim5)<start_count + elapse_count);
//
//    //Left side sensor
//	L_EM_ON;
//	start_count = __HAL_TIM_GET_COUNTER(&htim5);
//	while(__HAL_TIM_GET_COUNTER(&htim5)<start_count + elapse_count);
//	LLSensor = read_LL_Sensor - LLSensor_bg - LLSensor_DC;
//	L_EM_OFF;
//	start_count = __HAL_TIM_GET_COUNTER(&htim5);
//	if(LLSensor < 0)//error check
//		LLSensor = 0;
//	while(__HAL_TIM_GET_COUNTER(&htim5)<start_count + elapse_count);

	//right front sensor
	RF_EM_ON;
//	start_count = __HAL_TIM_GET_COUNTER(&htim5);
	while(__HAL_TIM_GET_COUNTER(&htim5)<150); //start_count + elapse_count);  //200
	RFSensor = read_RF_Sensor - RFSensor_bg - RFSensor_DC;
	RF_EM_OFF;
//	start_count = __HAL_TIM_GET_COUNTER(&htim5);
	if(RFSensor < 0)
		RFSensor = 0;
	while(__HAL_TIM_GET_COUNTER(&htim5)<200); //start_count + elapse_count);  //280


    //Left and Right sensors
	L_EM_ON;
	R_EM_ON;
//	start_count = __HAL_TIM_GET_COUNTER(&htim5);
	while(__HAL_TIM_GET_COUNTER(&htim5)<250); //start_count + elapse_count);  //340
	count = __HAL_TIM_GET_COUNTER(&htim5);
	LLSensor = read_LL_Sensor - LLSensor_bg - LLSensor_DC;
	RRSensor = read_RR_Sensor - RRSensor_bg - RRSensor_DC;
	L_EM_OFF;
	R_EM_OFF;
	if(LLSensor < 0)
		LLSensor = 0;
	if(RRSensor < 0)
		RRSensor = 0;
	while(__HAL_TIM_GET_COUNTER(&htim5)<300); //start_count + elapse_count); //420

	//diagonal sensors
	D_EM_ON;
	//	start_count = __HAL_TIM_GET_COUNTER(&htim5);
	while(__HAL_TIM_GET_COUNTER(&htim5)<350); //start_count + elapse_count);
	count = __HAL_TIM_GET_COUNTER(&htim5);
	DLSensor = read_DL_Sensor - DLSensor_bg - DLSensor_DC;
	DRSensor = read_DR_Sensor - DRSensor_bg - DRSensor_DC;
	D_EM_OFF;
	if(DLSensor < 0)
		DLSensor = 0;
	if(DRSensor < 0)
		DRSensor = 0;


//	readVolMeter();
//
//	LFSensor = LFSensor*reflectionRate/1000;
//	RFSensor = RFSensor*reflectionRate/1000;
//	DLSensor = DLSensor*reflectionRate/1000;
//	DRSensor = DRSensor*reflectionRate/1000;

	point++;
	if (point>=15){
		point = 0;
	}


	LBuff[point] = DLSensor;
	RBuff[point] = DRSensor;
	FLBuff[point] = LFSensor;
	FRBuff[point] = RFSensor;
	LLBuff[point] = LLSensor;
    RRBuff[point] = RRSensor;
	

//	LED7_OFF;
}




/*read voltage meter*/
void readVolMeter(void)
{          //3240 = 7.85V
	volMeter = read_Vol_Meter;//raw value
	voltage = (volMeter*ADC_REF_VOL/4095)* 2.8;//actual voltage value  ex) 8.2V = 8200
	// if (voltage<LOW_BAT_TH)
	// 	stop_it_all();
}

void stop_it_all(void){
	disp_state=LOW_BAT;
	displayUpdate();
	OFF_BUZZ;
	STOP_ROBOT;
	ALL_LED_OFF;
	TIM13_IT_STOP;
	return;
}




bool irBlink() {
	static uint32_t t3 = 1000;
	if (LFSensor > t3 || RFSensor > t3) {
			return true;
		}
	return false;
}

bool rightIrBlink(){
	static uint32_t t2 = 3000;
	if (DRSensor > t2) {
			return true;
		}
	return false;
}

bool leftIrBlink(){
	static uint32_t t1 = 3000;
	if (DLSensor > t1) {
			return true;
		}
	return false;
}

void calculateAndSaveAverages() {
	averageL = 0;
	averageR = 0;
	averageFL = 0;
	averageFR = 0;
	averageRR = 0;
	averageLL = 0;

    int i;
    // Calculate the average for each buffer
    for (i = 0; i < 15; i++) {
        averageL += LBuff[i];
        averageR += RBuff[i];
        averageFL += FLBuff[i];
        averageFR += FRBuff[i];
        averageLL += LLBuff[i];
        averageRR += RRBuff[i];
    }

    // Divide the sums by 15 to get the average
    averageL = averageL/15;
    averageR = averageR/15;
    averageFL = averageFL/15;
    averageFR = averageFR/15;
    averageLL = averageLL/15;
    averageRR = averageRR/15;
}

void getSensorReadings() {

	calculateAndSaveAverages();

	static float t1 = 600.0;  //490   //slit_tuning - 600    //800
	static float t2 = 600.0;          //slit_tuning - 600    //800
	static float t3 = 485.0;  //350   //slit_tuning - 400    //500


	if (averageR > t1){
		R = true;
		LED10_ON;
	} else {
		R = false;
		LED10_OFF;
	}

	if (averageL > t2){
		LED7_ON;
		L = true;
	} else {
		L = false;
		LED7_OFF;
	}

	if ((averageFL+averageFR)/2 > t3){
		LED8_ON;
		LED9_ON;
		F = true;
	} else {
		F = false;
		LED8_OFF;
		LED9_OFF;
	}

	// if (DLSensor > t1 && DRSensor > t1 && DRSensor > t1 && RFSensor > t1){
	// 	F = true;
	// 	R = true;
	// 	L = true;
	// } else if (DLSensor > t1 && DRSensor > t1){
	// 	F = false;
	// 	R = true;
	// 	L = true;
	// } else if (LFSensor > t1 && DLSensor > t1){
	// 	F = true;
	// 	R = false;
	// 	L = true;
	// } else if (RFSensor > t1 && DRSensor > t1){
	// 	F = true;
	// 	R = true;
	// 	L = false;
	// } else if (DLSensor > t1){
	// 	F = false;
	// 	R = false;
	// 	L = true;
	// } else if (DRSensor > t1){
	// 	F = false;
	// 	R = true;
	// 	L = false;
	// } else if (RFSensor > t2 || LFSensor > t2){
	// 	F = true;
	// 	R = false;
	// 	L = false;
	// } else {
	// 	F = false;
	// 	R = false;
	// 	L = false;
	// }
}

void irSideCalibrate(void)
{
	LED1_ON;
	float L_calibration_buffer[IR_BUFFER_LENGTH];
	float R_calibration_buffer[IR_BUFFER_LENGTH];
	float l_calibration_sum = 0;
	float r_calibration_sum = 0;

	for (u32 idx = 0; idx < BUFFER_LENGTH; idx++)
	{
		calculateAndSaveAverages();
		L_calibration_buffer[idx] = averageL;
		R_calibration_buffer[idx] = averageR;
		HAL_Delay(2);
		l_calibration_sum += L_calibration_buffer[idx];
		r_calibration_sum += R_calibration_buffer[idx];
	}

	l_offset = (float)l_calibration_sum / BUFFER_LENGTH;
	r_offset = (float)r_calibration_sum / BUFFER_LENGTH;
	MIDDLE_VALUE_DL = ((l_offset + r_offset)/2);
	LED1_OFF;
	return;
}

void irFrontCalibrate(void)
{
	LED5_ON;
	float FL_calibration_buffer[IR_BUFFER_LENGTH];
	float FR_calibration_buffer[IR_BUFFER_LENGTH];
	float FL_calibration_sum = 0;
	float FR_calibration_sum = 0;

	for (u32 idx = 0; idx < BUFFER_LENGTH; idx++)
	{
		calculateAndSaveAverages();
		FL_calibration_buffer[idx] = averageL;
		FR_calibration_buffer[idx] = averageR;
		HAL_Delay(2);
		FL_calibration_sum += FL_calibration_buffer[idx];
		FR_calibration_sum += FR_calibration_buffer[idx];
	}

	fl_offset = (float)FL_calibration_sum / BUFFER_LENGTH;
	fr_offset = (float)FR_calibration_sum / BUFFER_LENGTH;

	LED5_OFF;
	return;
}
